#!/usr/bin/python3 -uE
import socket as s
import signal
import struct
import threading as t
import binascii
import random
import sys
import os
import datetime
import time
import platform
import parse_triton_log as ptl
import collections as c

print ("Triton Data Server")

# Server address and properties
#HOST = 'localhost' # For local testing
HOST = '192.168.40.129'
PORT = 22127
QUEUE = 10
TIMEOUT = 10.0 # s, not used
LOG_FILE = "triton_data_server.log"
LOG_DIR = "C:\\Users\\user\\Documents\\Data Server\\"

# Log file parser properties
DELAY = 60.0

# Available query commands and corresponding codes
# !!! This was generated by the function ptl.update_column_names_file() !!!
CMD_DICT = {
    0x0000000000000001: "LineSize(bytes)",
    0x0000000000000002: "LineNumber",
    0x0000000000000004: "Time(secs)",
    0x0000000000000008: "P2 Condense (Bar)",
    0x0000000000000010: "P1 Tank (Bar)",
    0x0000000000000020: "P5 ForepumpBack (Bar)",
    0x0000000000000040: "P3 Still (mBar)",
    0x0000000000000080: "P4 TurboBack (mBar)",
    0x0000000000000100: "Dewar (mBar)",
    0x0000000000000200: "Input Water Temp",
    0x0000000000000400: "Output Water Temp",
    0x0000000000000800: "Oil Temp",
    0x0000000000001000: "Helium Temp",
    0x0000000000002000: "Motor Current",
    0x0000000000004000: "Low Pressure",
    0x0000000000008000: "High Pressure",
    0x0000000000010000: "PT2 Head T(K)",
    0x0000000000020000: "PT2 Head R(Ohm)",
    0x0000000000040000: "PT2 Plate T(K)",
    0x0000000000080000: "PT2 Plate R(Ohm)",
    0x0000000000100000: "Still Plate T(K)",
    0x0000000000200000: "Still Plate R(Ohm)",
    0x0000000000400000: "Cold Plate T(K)",
    0x0000000000800000: "Cold Plate R(Ohm)",
    0x0000000001000000: "MC Plate Cernox T(K)",
    0x0000000002000000: "MC Plate Cernox R(Ohm)",
    0x0000000004000000: "PT1 Head T(K)",
    0x0000000008000000: "PT1 Head R(Ohm)",
    0x0000000010000000: "PT1 Plate T(K)",
    0x0000000020000000: "PT1 Plate R(Ohm)",
    0x0000000040000000: "MC Plate RuO2 T(K)",
    0x0000000080000000: "MC Plate RuO2 R(Ohm)",
    0x0000000100000000: "Channel 9 T(K)",
    0x0000000200000000: "Channel 9 R(Ohm)",
    0x0000000400000000: "Channel 10 T(K)",
    0x0000000800000000: "Channel 10 R(Ohm)",
    0x0000001000000000: "Channel 11 T(K)",
    0x0000002000000000: "Channel 11 R(Ohm)",
    0x0000004000000000: "Channel 12 T(K)",
    0x0000008000000000: "Channel 12 R(Ohm)",
    0x0000010000000000: "Channel 13 T(K)",
    0x0000020000000000: "Channel 13 R(Ohm)",
    0x0000040000000000: "Still heater (W)",
    0x0000080000000000: "chamber heater (W)",
    0x0000100000000000: "IVC sorb heater (W)",
    0x0000200000000000: "turbo current(A)",
    0x0000400000000000: "turbo power(W)",
    0x0000800000000000: "turbo speed(Hz)",
    0x0001000000000000: "turbo motor(C)",
    0x0002000000000000: "turbo bottom(C)"
}

# Expected response length (in bytes) for any query
SEND_LEN = 4 # 32 bit floats
RECV_LEN = 8 # 64 bit values

# State control variables
comms = True
queueing = True

# Log function
def log_message(message):
    
    # Format the message
    final_str = str(datetime.datetime.now().strftime('%c'))
    final_str += ": %s\n" % message
    
    # Append contents
    fd = open(LOG_DIR+LOG_FILE,'a')
    fd.write(final_str)
    fd.close()

# Queue handler function
def queue_handler(deque_list):
    
    print ("Logging queue thread started.")
    while queueing:
    
        # Get latest row
        row_data = ptl.getRowData()
    
        # Read all values every DELAY seconds
        for key in list(CMD_DICT.values()):
            val = float(row_data[key])
            deque_list[key].append(val)
        
        # Wait
        time.sleep(DELAY)
    print ("Logging queue thread stopped.")

# Client handler function
def client_handler(clientsock,addr,deque_list):
    
    # Receive data
    data = recv_data(clientsock)
    if data == b'':
        raise RuntimeError("socket connection broken")

    # Convert command from bytes to int
    cmd = int.from_bytes(data,sys.byteorder)

    #  Get data from Queue
    f = 0.0
    try:
        f = deque_list[CMD_DICT[cmd]][0]
    except KeyError as e:
        log_message("[ERROR]: Unrecognised command from host '%s:%i': '%s'" % (addr[0],addr[1],hex(cmd)))
        pass
    
    # Format response data
    r_bytes = bytearray(struct.pack("f",f))
    r_len = len(r_bytes)
    r_str = b''
    for j in range(r_len):
        r_str += r_bytes[j].to_bytes(1,sys.byteorder)
    
    # Send the response
    send_data(clientsock,r_str)

# Send function
def send_data(sock,cmd):
    totalsent = 0
    while totalsent < SEND_LEN:
        sent = sock.send(cmd[totalsent:])
        if sent == 0:
            raise RuntimeError("socket connection broken")
        totalsent = totalsent + sent

# Receive function
def recv_data(sock):
    chunks = []
    bytes_recd = 0
    while bytes_recd < RECV_LEN:
        chunk = sock.recv(min(RECV_LEN - bytes_recd, 1024))
        if chunk == b'':
            raise RuntimeError("socket connection broken")
        chunks.append(chunk)
        bytes_recd = bytes_recd + len(chunk)
    return b''.join(chunks)

# Keyboard interrupt handler
def interrupt_handler(sig,frame):
    global comms
    global queueing
    print ("\nShutting down server.")
    comms = False
    queueing = False
    os._exit(0)

# Socket class
class XLDServer:
    def __init__(self,server_addr,server_port,server_queue):
        self.addr = server_addr
        self.port = server_port
        self.queue = server_queue
        
        # State machine control
        self.threads = []
        self.exit = False
        
        # Get platform information
        self.system = platform.system()
        
        # Server information
        print ("Server Information:")
        print (" Running on:")
        print ("   %s" % platform.platform())
        print ("   %s" % platform.machine())
        print (" Available interfaces:")
        if self.system == 'Linux':
            for intf in s.if_nameindex():
                print ("  %s" % repr(intf))
        print (" Server hostname: %s" % s.gethostname())
        print (" Host address: %s" % s.gethostbyname(s.gethostname()))
        print (" Address information:")
        ret = s.getaddrinfo(HOST,PORT)
        for elem in ret:
            print ("  %s" % repr(elem))
        if self.system == 'Windows':
            print ("\n!!IMPORTANT!!  Close the server by ending the task in Task Manager.\n")
        
        
        # Create the data queues
        self.deque_list = {}
        for key in list(CMD_DICT.values()):
            self.deque_list[key] = c.deque(maxlen=1)
    
    # Start the server process
    def start(self):
        
        print ("Starting server on %s:%i." % (s.gethostbyname(self.addr),self.port))
        log_message("[INFO] Starting server on %s:%i." % (s.gethostbyname(self.addr),self.port))
        self.sock = s.socket(s.AF_INET, s.SOCK_STREAM)
        self.sock.bind((s.gethostbyname(self.addr), self.port))
        self.sock.listen(self.queue)
        
        # Assign the interrupt handler
        # Doesn't work on Windows
        if self.system == 'Linux':
            signal.signal(signal.SIGINT,interrupt_handler)
        
        # Start the data queueing thread
        self.queueing_thread = t.Thread(target=queue_handler, args=(self.deque_list,))
        self.queueing_thread.start()
        
        # Start comms loop
        while comms:
            (clientsock,addr) = self.sock.accept()
            (host,port) = addr
            print ("Connected to host '%s:%i'." % (host,port))
            log_message("[INFO] Connected to host %s:%i." % (host,port))

            #  Start thread
            th = t.Thread(target=client_handler, args=(clientsock,addr,self.deque_list))
            self.threads.append(th)
            th.start()
            
            # Clean finished threads
            for thr in self.threads:
              alive = thr.is_alive()
              if not alive:
                  self.threads.remove(thr)
              
        # Exiting
        self.sock.close()
        print ("Server closed.")
        log_message("[INFO] Server closed.")
            
# Run the server
server = XLDServer(HOST,PORT,QUEUE)
server.start()

